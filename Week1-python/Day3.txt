NameError: is occurs where the unidentify is present
print : =>in version2 is statement,not a function.
        =>in version3 is function
Operator ::






Bitwise operator:

5>6 and 3<7
- False
5>6 or 3<7
- True
not 0  => Zero is True
- True
not 6 => Positive and Negative numbers are False
- False
not -5 => Positive and Negative numbers are False
- False
7&9
- 1
7|9
- 15
7^9
- 14



shift: 
=> >> << -it the 8bit represention => 00000000
=> >>> and <<< is not present in python

5 << 3 0101 = 00101000
-  40
5 << 4 
-  80
5 >> 2
-  1
5>>>3  
SyntaxError: invalid syntax
5<<<4
SyntaxError: invalid syntax


Members shift operator:
=> to check the whether the data is present or not


identity operator:
=> Check the whether the data is belong to or not

num1=10
type(num1)
<class 'int'>
num1 is int
False
type(num1) is int
True
num1 is int
False

Concateing:
=>  +
=> , comma has a separator
num1=10
print('hi'+'hello')
hihello
print(num1+10)
20
print(num1+'10')
Traceback (most recent call last):
  File "<pyshell#27>", line 1, in <module>
    print(num1+'10')
TypeError: unsupported operand type(s) for +: 'int' and 'str'
print('hi'+10)
Traceback (most recent call last):
  File "<pyshell#28>", line 1, in <module>
    print('hi'+10)
TypeError: can only concatenate str (not "int") to str

print('sum: '+num1+10)
Traceback (most recent call last):
  File "<pyshell#29>", line 1, in <module>
    print('sum: '+num1+10)
TypeError: can only concatenate str (not "int") to str

=> , comma has a separator
print('sum: ',num1+10)
sum:  20

print('sum: '+'\n',num1+10)
sum: 
 20
print('sum: ','\n',num1+10)
sum:  
 20

input:
=> it can give the input value 

input()
hi
'hi'
input("Enter the num: ")
Enter the num: 5
'5'
input()
True

int(input("Enter the num: "))
Enter the num: 5
5
bool(input('Enter the num: '))
Enter the num: 0
True
bool(input('Enter the num'))
Enter the num
False
=> any non empty in boolean is true and if it has empty is false
=> it has take the input has the string by ignoring data





Typecasting::
implicit 
explicit

implicit Typecasting:
=>Implicit typecasting means Python automatically converts one data type into another without asking the programmer.
=>bool  →  int  →  float  →  complex

int(input('Enter the num: '))   
Enter the num: 5
5
float(input('Enter the num: '))   
Enter the num: 5
5.0
bool(input('Enter the num: '))
Enter the num: 0
True
a = 5   
b = 3j  
c = a + b   
print(c)   
(5+3j)
print(type(c))   
<class 'complex'>

Status  T  T  T  F
data    5  0 -9  

int     5  0 -9  Error
bool    T  T  T  F


Enter the num: 5
5
int(input('Enter the num: '))  
Enter the num: 9
9
int(input('Enter the num: '))  
Enter the num: -9
-9
int(input('Enter the num: '))   
Enter the num: 
Traceback (most recent call last):
  File "<pyshell#51>", line 1, in <module>
    int(input('Enter the num: '))
ValueError: invalid literal for int() with base 10: ''


NameSpaces:
=> it is used to identify 
=> connected to object
=>A namespace is a container that holds names (identifiers) and their corresponding objects.

Types of NameSpaces:
| Namespace Type           | Scope                                                       | Lifetime                       |
| ------------------------ | ----------------------------------------------------------- | ------------------------------ |
| **Built-in**             | Python keywords and built-in functions (`print()`, `len()`) | Lifetime of program            |
| **Global**               | Names defined at the top-level of a file or module          | Lifetime of program            |
| **Local**                | Names inside a function or method                           | Lifetime of function call      |
| **Enclosing (Nonlocal)** | Names in enclosing functions for nested functions           | Lifetime of enclosing function |

example:
x = 10  # global namespace
def outer():
    y = 20  # enclosing namespace   
    def inner():
        z = 30  # local namespace
        print(x, y, z)  
    inner()
outer()

output:10 20 30

LEGB Rule
Python searches for a name in this order:
L → Local (inside current function)
E → Enclosing (in outer function)
G → Global (top-level of module)
B → Built-in (Python built-ins)

String:
=>A string is a sequence of characters enclosed in single ', double ", or triple quotes ''' / """.

'hi'  
'hi'
"hi"  
'hi'
"hello asif"  
'hello asif'
'asif's house'    
SyntaxError: unterminated string literal (detected at line 1)
"asif's house"   
"asif's house"
'asif"s house'  
'asif"s house'


str='asif'   
str  
'asif'

==> Length: length if the String in indexs
len(str)  
4

str[1]   
's'
str[3]   
'f'
str[-2]   
'i'
str[-4]   
'a'

str[0:2]   
'as'
str[1:3]   
'si'

str[0:3:1]   
'asi'
str[0:3:2]   
'ai'

str[0::2]   
'ai'
str[0::3]   
'af'

str[-3:-1]  
'si'
str[-1:-3]  
''

str[-3:-1:1]
'si'

==> Methods in String:
str.capitalize()  
'Asif'
str.upper()   
'ASIF'
str.lower()   
'asif'
str.count('a')   
1
str.endswith('f')    
True
str.endswith('s')    
False
str.find('s')    
1
str.find('m')----- In find if the character is not present it get negative value   
-1
str.index('s')  
1
str.index('m')   ------it get the error
Traceback (most recent call last):
  File "<pyshell#99>", line 1, in <module>
    str.index('m')
ValueError: substring not found

str.encode('utf-8')---The prefix b indicates it is a bytes object, not a string.
b'asif           -----Each character in 'asif' is converted to its UTF-8 byte representation: 

str.replace('i','a')  
'asaf'

==>Split:
=>The split() method divides a string into a list of substrings based on a separator.
str1='hello asif how are you'   
str1.split()    
['hello', 'asif', 'how', 'are', 'you']
str1.split('o')  
['hell', ' asif h', 'w are y', 'u']

==>Join
=>it join str1 single character to the string
str1.join(str)  
'ahello asif how are youshello asif how are youihello asif how are youf'

==>strip:
=>Remove all the whitespaces
str2='      mohammad    '   
str2.strip()    
'mohammad'

Data Structures:
=>A data structure is a way to store, organize, and manage data so it can be used efficiently.
=>List, Tuple, Set, Dict

==>list:
=>Represent-[] and that are ordered and changeable
=>It allow the duplicates
=>it is mutable
=>it can access by numbers indexs
=>order of insertions
numbers=[10,20,30] 
numbers 
[10, 20, 30]
numbers.append(40)--- it can be add the data in last   
numbers 
[10, 20, 30, 40]
numbers[2]=300----it modifty the index
=>Methods
count:
numbers.count(20)    
1
index:
numbers.index(30)   
2
=>insert:
numbers.insert(4,500)
=>remove
numbers.remove(300)
=>pop
numbers.pop()    ---- if don,t give anything it has pop last elements  
500
numbers.pop(-2) ---index has given
20
=>reserve  ---- it change the order
numbers.reverse()   
numbers    
[40, 10]
=>sort ---- it sorted in ascending order
numbers.sort()   
numbers   
[10, 40]
=>copy  --- it copy to another the variable and it has the different addresses
num5=numbers.copy()  
num5   
[10, 40]
=>extend --- it has the concate the 2 lists
numbers.extend(num5)   
numbers  
[10, 40, 10, 40]
=>clear --- it has the clear the list and become the empty
numbers.clear()  
numbers   
[]
=>del --- it has the delete
del(numbers)   
numbers  
Traceback (most recent call last):
  File "<pyshell#140>", line 1, in <module>
    numbers
NameError: name 'numbers' is not defined. Did you forget to import 'numbers'?


=> to get address it has - id(variable)
id(str2)   
2441736947888

==>Tuple:: ---- double '_' are dradans or magic methods
=>A tuple in Python is an ordered and immutable collection of items --- we can't modifty 
=> it respresent--()
=>it allow dulipcates
=>it is immutable and read only
=> number index is available
=>order of insertions
tupl=(10,20,30)

Methods
=>count
tupl.count(10) 
1
=>index
tupl.index(30)    
2

==>Set
=> it represent in {}
=>it has to be unique or Duplicate elements are automatically removed.
=> and the mutable
=>no index iterate
=> it doesn't in order of insertions
Methods:
=>add
set1.add(100)   
set1   
{50, 20, 100, 40, 10, 30}
=>Union  --- it remove the same elements which is present in 2 sets
set1={10,20,30,40,50}
set2={90,80,70,60,50}
set1.union(set2)  
{100, 70, 40, 10, 80, 50, 20, 90, 60, 30}
=>Intersection --- it give the the same elements which is present in 2 sets
set1.intersection(set2)  
{50}
=>difference
set1.difference(set2)    
{100, 40, 10, 20, 30}
=>discard
set1.discard(20)   
set1   
{50, 100, 40, 10, 30}



==>Dict
=>it has the keys and values ----k:v
=>keys has be unique
=>values is dulipcates
=>it is mutable
=>it has homogenours and heteragenours data
dict1={1:10,2:20}   
dict1   
{1: 10, 2: 20}
set1.discard(20)   
set1   
{50, 100, 40, 10, 30}
dict1={1:10,2:20}   
dict1   
{1: 10, 2: 20}
dict1[2]   
20
dict1[2]=300   
dict1   
{1: 10, 2: 300}
dict2={'rno':'123','name':'Asif'}    
dict2    
{'rno': '123', 'name': 'Asif'}
dict2['rno']    
'123'
dict2['rno']=123
dict2['rno']
123
dict2['ph']=12232456789
dict2    
{'rno': 123, 'name': 'Asif', 'ph': 12232456789}

Methods::
=>get
ph=dict2.get('ph')    
ph    
12232456789
=>keys
dict2.keys()   
dict_keys(['rno', 'name', 'ph'])
=>values
dict2.values()   
dict_values([123, 'Asif', 12232456789])
=>pop
dict1.pop(2)    
300
dict1    
{1: 10}

